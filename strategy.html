<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iron Dominion: World Strategy</title>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --text-color: #ffd700;
            --accent-color: #ff9933;
            --border-color: #8b7355;
            --panel-bg: rgba(20, 20, 20, 0.95);
            --topbar-bg: rgba(10, 10, 10, 0.95);
            --success: #44ff44;
            --danger: #ff4444;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
        }

        /* --- TOP BAR (HOI4 Style) --- */
        #top-bar {
            height: 50px;
            background: var(--topbar-bg);
            border-bottom: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 100;
        }

        .top-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stat-box {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1em;
            font-weight: bold;
            color: #fff;
            background: rgba(255,255,255,0.05);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .stat-icon { font-size: 1.2em; }

        #country-selector {
            background: #222;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 5px;
            font-family: inherit;
            font-weight: bold;
        }

        /* --- MAP AREA --- */
        #map-area {
            flex-grow: 1;
            position: relative;
            background: #050505;
            overflow: hidden;
            cursor: grab;
        }

        #map-area:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
        }

        /* --- PROVINCE PANEL (Bottom Left) --- */
        #province-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            padding: 15px;
            display: none; /* Hidden by default */
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            z-index: 90;
        }

        .panel-header {
            color: var(--accent-color);
            font-weight: bold;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
            margin-bottom: 10px;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        /* --- LOG PANEL (Bottom Right) --- */
        #log-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 150px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #333;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.8em;
            color: #aaa;
            pointer-events: none; /* Let clicks pass through if needed, but scroll might need events */
            pointer-events: auto;
        }

        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-entry.war { color: #ff4444; }
        .log-entry.peace { color: #44ff44; }
        .log-entry.info { color: #88ccff; }

        /* --- BUTTONS --- */
        .btn {
            background: #333;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            cursor: pointer;
            text-transform: uppercase;
            font-family: inherit;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.2s;
        }
        .btn:hover { background: var(--accent-color); color: #000; }
        .btn-block { width: 100%; margin-bottom: 5px; }
        .btn-danger { border-color: var(--danger); color: var(--danger); }
        .btn-danger:hover { background: var(--danger); color: #000; }

        /* --- MODALS --- */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: var(--panel-bg);
            border: 2px solid var(--accent-color);
            padding: 30px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 153, 51, 0.2);
        }

        h1 { margin: 0 0 20px 0; color: var(--accent-color); }
        h2 { margin: 0 0 15px 0; color: #fff; font-size: 1.2em; }
        p { line-height: 1.5; color: #ccc; margin-bottom: 20px; }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--accent-color);
            padding: 8px;
            pointer-events: none;
            display: none;
            z-index: 200;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- TOP BAR -->
    <div id="top-bar">
        <div class="top-section">
            <div style="font-weight: bold; color: var(--accent-color); margin-right: 15px;">IRON DOMINION</div>
            <div id="player-country-display" style="font-weight: bold; color: #fff; border: 1px solid #444; padding: 5px 10px; background: #222;">-</div>
        </div>

        <div class="top-section stats">
            <div class="stat-box" title="Manpower"><span class="stat-icon">üë•</span> <span id="player-manpower">0</span></div>
            <div class="stat-box" title="Industry"><span class="stat-icon">üè≠</span> <span id="player-industry">0</span></div>
            <div class="stat-box" title="Territory"><span class="stat-icon">üö©</span> <span id="player-provinces">0</span></div>
        </div>

        <div class="top-section">
            <div style="margin-right: 15px; color: #aaa;">DAY <span id="game-day" style="color: #fff; font-weight: bold;">1</span></div>
            <button class="btn" onclick="game.togglePause()" id="btn-pause">‚è∏</button>
            <button class="btn" onclick="window.location.href='index.html'" style="margin-left: 10px;">EXIT</button>
        </div>
    </div>

    <!-- MAP AREA -->
    <div id="map-area">
        <canvas id="gameCanvas"></canvas>
        <div id="loading-overlay" style="position: absolute; top:0; left:0; width:100%; height:100%; background: #000; display: flex; justify-content: center; align-items: center; z-index: 500;">
            <div style="text-align: center;">
                <h2 style="color: var(--accent-color);">GENERATING WORLD...</h2>
                <p id="loading-text" style="color: #888;">Subdividing provinces...</p>
            </div>
        </div>
        <div id="tooltip"></div>

        <!-- PROVINCE PANEL -->
        <div id="province-panel">
            <div class="panel-header">
                <span id="prov-name">Province</span>
                <span id="prov-id" style="font-size: 0.7em; color: #666;">#000</span>
            </div>
            
            <div style="margin-bottom: 15px;">
                <div class="stat-row"><span>Owner:</span> <span id="prov-owner">-</span></div>
                <div class="stat-row"><span>Garrison:</span> <span id="prov-army" style="color: #aaa;">0</span></div>
                <div class="stat-row"><span>Fortification:</span> <span id="prov-defense" style="color: #aaa;">0%</span></div>
            </div>

            <div id="owner-actions">
                <button class="btn btn-block" onclick="game.actions.recruit()">Recruit (+50 Army) <span style="float:right; color:#888">100MP</span></button>
                <button class="btn btn-block" onclick="game.actions.build('factory')">Build Factory <span style="float:right; color:#888">500MP</span></button>
                <button class="btn btn-block" onclick="game.actions.build('fort')">Build Fort <span style="float:right; color:#888">300MP</span></button>
                <button class="btn btn-block btn-danger" onclick="game.actions.attackMode()">‚öî LAUNCH ASSAULT</button>
            </div>
            
            <div id="admin-actions" style="margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                <div id="diplomacy-section" style="display: none;">
                    <div style="color: #aaa; font-size: 0.9em; margin-bottom: 5px;">DIPLOMACY</div>
                    <div id="diplomacy-status" style="margin-bottom: 5px; font-size: 0.8em;">Status: Neutral</div>
                    <button class="btn btn-block" id="btn-nap" onclick="game.diplomacy.proposeNAP()">Non-Aggression Pact</button>
                    <button class="btn btn-block" id="btn-justify" onclick="game.diplomacy.startJustification()">Justify War Goal</button>
                    <button class="btn btn-block btn-danger" id="btn-declare-war" onclick="game.diplomacy.declareWar()">DECLARE WAR</button>
                </div>
                <button class="btn btn-block" style="background: #442222; margin-top: 10px;" onclick="game.actions.cheatAnnex()">‚ö† FORCE ANNEX</button>
            </div>
        </div>

        <!-- LOG PANEL -->
        <div id="log-panel">
            <div style="color: #666; font-size: 0.9em; border-bottom: 1px solid #333; margin-bottom: 5px;">COMMUNICATIONS LOG</div>
            <div id="log-content"></div>
        </div>
    </div>
</div>

<!-- SETUP MODAL -->
<div id="setup-modal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <h1>SELECT YOUR NATION</h1>
        <p>Choose a superpower to lead into the new world order.</p>
        
        <div id="country-selection-list" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 30px;">
            <!-- Populated by JS -->
        </div>

        <div style="text-align: left; margin: 20px 0; background: rgba(0,0,0,0.3); padding: 15px;">
            <h2>BRIEFING</h2>
            <p><strong>DRAG</strong> to pan the map view.</p>
            <p><strong>CLICK</strong> on a province to select it.</p>
            <p><strong>MANAGE</strong> your economy and army using the bottom-left panel.</p>
            <p><strong>ATTACK</strong> neighbors by selecting your province, clicking "Launch Assault", then clicking a target.</p>
        </div>
    </div>
</div>

<!-- GAME OVER MODAL -->
<div id="overlay" class="modal" style="display: none;">
    <div class="modal-content">
        <h1 id="overlay-title">CAMPAIGN ENDED</h1>
        <p id="overlay-msg">The world has been unified.</p>
        <button class="btn" style="padding: 15px 40px;" onclick="location.reload()">RESTART WORLD</button>
    </div>
</div>

<script>
/**
 * IRON DOMINION - World Strategy Engine [R30]
 */

const CONFIG = {
    tickRate: 800,
    colors: {
        water: '#080808',
        neutral: '#2a2a2a',
        highlight: 'rgba(255, 255, 255, 0.15)',
        selected: 'rgba(255, 215, 0, 0.5)',
        border: '#000'
    }
};

// --- WORLD DATA ---
let countries = {};
let provinces = [];
let game = null;

// --- GENERATION ---

class Province {
    constructor(id, feature) {
        this.id = id;
        this.feature = feature;
        this.owner = null; // Set externally now
        this.name = "Province";
        this.army = 50 + Math.floor(Math.random() * 100);
        this.buildings = { factory: 0, fort: 0 };
        this.neighbors = [];
        
        // Calculate centroid and bounds
        this.polygons = [];
        if (feature.geometry.type === 'Polygon') {
            this.polygons.push(feature.geometry.coordinates[0]);
        } else if (feature.geometry.type === 'MultiPolygon') {
            feature.geometry.coordinates.forEach(poly => this.polygons.push(poly[0]));
        }
        
        this.center = this.calculateCentroid();
        this.bounds = this.calculateBounds();
    }

    calculateCentroid() {
        let x = 0, y = 0, n = 0;
        this.polygons.forEach(poly => {
            poly.forEach(pt => {
                x += pt[0];
                y += pt[1];
                n++;
            });
        });
        return { x: x/n, y: y/n };
    }

    calculateBounds() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        this.polygons.forEach(poly => {
            poly.forEach(pt => {
                if (pt[0] < minX) minX = pt[0];
                if (pt[0] > maxX) maxX = pt[0];
                if (pt[1] < minY) minY = pt[1];
                if (pt[1] > maxY) maxY = pt[1];
            });
        });
        return { minX, minY, maxX, maxY };
    }
}

const MAJOR_NATIONS = {
    "USA": { color: "#4488ff", name: "United States" },
    "CHN": { color: "#ff4444", name: "China" },
    "RUS": { color: "#cc4444", name: "Russia" },
    "DEU": { color: "#aaaaaa", name: "Germany" },
    "FRA": { color: "#4444ff", name: "France" },
    "GBR": { color: "#cc8888", name: "United Kingdom" },
    "JPN": { color: "#ffffff", name: "Japan" },
    "BRA": { color: "#44cc44", name: "Brazil" },
    "IND": { color: "#ff8844", name: "India" },
    "CAN": { color: "#ffcccc", name: "Canada" },
    "AUS": { color: "#44ccff", name: "Australia" },
    "ITA": { color: "#44aa44", name: "Italy" },
    "ESP": { color: "#cccc44", name: "Spain" },
    "TUR": { color: "#44aaaa", name: "Turkey" },
    "ZAF": { color: "#aa44aa", name: "South Africa" },
    "EGY": { color: "#cccc88", name: "Egypt" },
    "SAU": { color: "#448844", name: "Saudi Arabia" },
    "IRN": { color: "#44aa88", name: "Iran" },
    "PAK": { color: "#448888", name: "Pakistan" },
    "IDN": { color: "#aa8844", name: "Indonesia" },
    "KOR": { color: "#4444aa", name: "South Korea" },
    "MEX": { color: "#88aa44", name: "Mexico" }
};

async function generateWorldMap() {
    provinces = [];
    countries = {};
    
    const loadingText = document.getElementById('loading-text');
    
    try {
        const response = await fetch('assets/world.json');
        const data = await response.json();
        
        let provIndex = 0;

        // Process each country
        for (let i = 0; i < data.features.length; i++) {
            const feature = data.features[i];
            loadingText.innerText = `Processing ${feature.properties.name}...`;
            
            // 1. Setup Country Data
            let color = `hsl(${Math.random() * 360}, 60%, 40%)`;
            let name = feature.properties.name;
            
            if (MAJOR_NATIONS[feature.id]) {
                color = MAJOR_NATIONS[feature.id].color;
            }

            countries[feature.id] = {
                id: feature.id,
                name: name,
                color: color,
                manpower: 1000 + Math.floor(Math.random() * 2000),
                industry: 5 + Math.floor(Math.random() * 10),
                ai: true,
                aggression: Math.random(),
                diplomacy: { pacts: [], justifications: [], wars: [] }
            };

            // 2. Generate Provinces (Subdivision)
            // First, flatten MultiPolygons to Polygons
            let polys = [];
            if (feature.geometry.type === 'Polygon') {
                polys.push(feature);
            } else if (feature.geometry.type === 'MultiPolygon') {
                // Split MultiPolygon into individual Polygons
                feature.geometry.coordinates.forEach(coords => {
                    polys.push(turf.polygon(coords, feature.properties));
                });
            }

            // Now process each polygon chunk
            for (let poly of polys) {
                const area = turf.area(poly);
                // Thresholds for subdivision (in square meters, roughly)
                // Russia is huge, islands are small.
                // 100,000,000,000 is roughly a small country size
                
                let numSplits = 1;
                if (MAJOR_NATIONS[feature.id]) numSplits = 4; // Base for majors
                if (area > 500000000000) numSplits += 2;
                if (area > 2000000000000) numSplits += 4;
                if (area > 10000000000000) numSplits += 8; // Russia/Canada size
                
                // Don't split tiny islands
                if (area < 50000000000) numSplits = 1;

                if (numSplits > 1) {
                    try {
                        const bbox = turf.bbox(poly);
                        // Generate random points
                        const points = turf.randomPoint(numSplits, {bbox: bbox});
                        
                        // Voronoi requires points to be inside the bbox, which they are.
                        // But we need to clip the voronoi cells to the polygon.
                        // Turf voronoi returns a FeatureCollection of Polygons.
                        const voronoi = turf.voronoi(points, {bbox: bbox});
                        
                        voronoi.features.forEach(cell => {
                            if (cell) {
                                const clipped = turf.intersect(cell, poly);
                                if (clipped) {
                                    // Clean up geometry if it became MultiPolygon (rare but possible)
                                    if (clipped.geometry.type === 'Polygon') {
                                        createProvince(provIndex++, clipped, feature.id);
                                    } else if (clipped.geometry.type === 'MultiPolygon') {
                                        clipped.geometry.coordinates.forEach(c => {
                                            createProvince(provIndex++, turf.polygon(c), feature.id);
                                        });
                                    }
                                }
                            }
                        });
                    } catch (err) {
                        // Fallback if geometry fails
                        console.warn("Subdivision failed for", feature.properties.name, err);
                        createProvince(provIndex++, poly, feature.id);
                    }
                } else {
                    createProvince(provIndex++, poly, feature.id);
                }
            }
            
            // Yield to UI thread every few countries to update loading text
            if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
        }

        // Calculate neighbors (simple distance based for now)
        // This is O(N^2) but N is small (~180)
        // With provinces N might be ~600. O(N^2) is 360,000 checks. Fast enough.
        loadingText.innerText = "Calculating logistics...";
        await new Promise(r => setTimeout(r, 10));

        provinces.forEach(p1 => {
            provinces.forEach(p2 => {
                if (p1 === p2) return;
                // Use bounding box check first for speed
                if (p1.bounds.maxX < p2.bounds.minX || p1.bounds.minX > p2.bounds.maxX ||
                    p1.bounds.maxY < p2.bounds.minY || p1.bounds.minY > p2.bounds.maxY) return;

                const dx = p1.center.x - p2.center.x;
                const dy = p1.center.y - p2.center.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 5) { // Tighter threshold for provinces
                    p1.neighbors.push(p2.id);
                }
            });
        });
        
        console.log(`Generated ${provinces.length} provinces.`);
        document.getElementById('loading-overlay').style.display = 'none';
        
    } catch (e) {
        console.error("Failed to load map data", e);
        document.getElementById('loading-text').innerText = "Error loading map data!";
    }
}

function createProvince(id, feature, ownerId) {
    // Ensure properties exist
    feature.properties = feature.properties || {};
    feature.properties.name = countries[ownerId].name; // Inherit country name for now
    
    // Create province object
    // We need to modify the Province class slightly or just pass the feature
    // The Province class expects 'feature' to have 'id' which is the country ID usually.
    // But here 'id' is the province index.
    
    // Let's manually construct to match existing structure
    const p = new Province(id, feature);
    p.owner = ownerId; // Explicitly set owner
    p.name = `${countries[ownerId].name} ${generateRegionName()}`;
    provinces.push(p);
}

const REGION_NAMES = ["Region", "Sector", "Zone", "District", "Area", "Territory", "Province", "State"];
function generateRegionName() {
    return REGION_NAMES[Math.floor(Math.random() * REGION_NAMES.length)] + " " + Math.floor(Math.random()*100);
}

function generateCityName(region) {
    return "City"; // Deprecated
}

// --- GAME ENGINE ---

game = {
    canvas: null,
    ctx: null,
    day: 1,
    paused: false,
    selectedProvId: null,
    attackMode: false,
    timer: null,
    playerCountry: null,
    camera: { x: 0, y: 0, zoom: 4, isDragging: false, lastX: 0, lastY: 0 },

    init: async function() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        const mapArea = document.getElementById('map-area');
        this.canvas.width = mapArea.clientWidth;
        this.canvas.height = mapArea.clientHeight;
        
        await generateWorldMap();
        
        // Check for country parameter in URL
        const urlParams = new URLSearchParams(window.location.search);
        const countryParam = urlParams.get('country');
        
        if (countryParam && countries[countryParam]) {
            this.startGame(countryParam);
        } else {
            this.initSetup();
        }
        
        this.render();
        
        // Input Handlers
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
        
        window.addEventListener('resize', () => {
            this.canvas.width = mapArea.clientWidth;
            this.canvas.height = mapArea.clientHeight;
            this.render();
        });
        
        if (!this.playerCountry) {
            this.log("Waiting for commander selection...", "info");
        }
    },

    initSetup: function() {
        document.getElementById('setup-modal').style.display = 'flex';
        const container = document.getElementById('country-selection-list');
        container.innerHTML = "";
        
        // Sort countries by name
        const sortedCountries = Object.values(countries).sort((a, b) => a.name.localeCompare(b.name));

        sortedCountries.forEach(c => {
            if (c.id === "NEUTRAL") return;
            
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.style.padding = '10px';
            btn.style.width = '180px';
            btn.style.border = `1px solid ${c.color}`;
            btn.style.textAlign = 'left';
            btn.style.background = 'rgba(0,0,0,0.5)';
            
            btn.innerHTML = `
                <div style="color: ${c.color}; font-weight: bold;">${c.name}</div>
                <div style="font-size: 0.8em; color: #aaa;">MP: ${c.manpower}</div>
            `;
            
            btn.onclick = () => this.startGame(c.id);
            container.appendChild(btn);
        });
    },

    startGame: function(countryId) {
        this.playerCountry = countryId;
        document.getElementById('setup-modal').style.display = 'none';
        document.getElementById('player-country-display').innerText = countries[countryId].name;
        document.getElementById('player-country-display').style.color = countries[countryId].color;
        document.getElementById('player-country-display').style.borderColor = countries[countryId].color;
        
        this.updateUI();
        this.timer = setInterval(() => this.tick(), CONFIG.tickRate);
        this.log(`Commander assigned to ${countries[countryId].name}. Operation started.`, "info");
        this.render();
    },

    switchPlayer: function(countryId) {
        this.playerCountry = countryId;
        this.selectedProvId = null;
        this.attackMode = false;
        this.log(`Command switched to ${countries[countryId].name}`, "info");
        this.updateUI();
        this.render();
    },

    tick: function() {
        if (this.paused) return;
        this.day++;
        document.getElementById('game-day').innerText = this.day;

        Object.values(countries).forEach(c => {
            if (c.id === "NEUTRAL") return;
            
            // Diplomacy Updates
            if (c.diplomacy) {
                // Decrease pact duration
                c.diplomacy.pacts = c.diplomacy.pacts.filter(p => {
                    p.turns--;
                    if (p.turns <= 0) {
                        if (c.id === this.playerCountry) game.log(`Non-Aggression Pact with ${countries[p.with].name} expired.`, "info");
                        return false;
                    }
                    return true;
                });

                // Increase justification progress
                c.diplomacy.justifications.forEach(j => {
                    if (j.progress < 100) {
                        j.progress += 2; // 2% per day
                        if (j.progress >= 100) {
                            j.progress = 100;
                            if (c.id === this.playerCountry) game.log(`War Goal against ${countries[j.target].name} is ready!`, "war");
                        }
                    }
                });
            }

            const myProvs = provinces.filter(p => p.owner === c.id);
            if (myProvs.length === 0) return;

            let income = 10 + (myProvs.length * 2);
            const factories = myProvs.reduce((sum, p) => sum + p.buildings.factory, 0);
            income += factories * 5;
            
            c.manpower += income;
            c.industry = factories;

            if (c.ai && c.id !== this.playerCountry) this.processAI(c, myProvs);
        });

        this.updateUI();
        this.render();
    },

    processAI: function(country, myProvs) {
        // AI Diplomacy Logic
        if (country.diplomacy) {
            // Check neighbors
            const neighbors = new Set();
            myProvs.forEach(p => {
                p.neighbors.forEach(nid => {
                    const n = provinces.find(pr => pr.id === nid);
                    if (n.owner !== country.id) neighbors.add(n.owner);
                });
            });
            
            neighbors.forEach(targetId => {
                if (targetId === "NEUTRAL") return;
                const target = countries[targetId];
                
                // If aggressive and strong, justify war
                if (country.aggression > 0.7 && country.manpower > target.manpower * 1.2) {
                    if (!country.diplomacy.wars.includes(targetId) && 
                        !country.diplomacy.pacts.find(p => p.with === targetId) &&
                        !country.diplomacy.justifications.find(j => j.target === targetId)) {
                            
                        country.diplomacy.justifications.push({ target: targetId, progress: 0 });
                        // Only log if player is involved or nearby? For now log all major events
                        if (targetId === this.playerCountry) {
                            this.log(`WARNING: ${country.name} is justifying a war goal against you!`, "war");
                        }
                    }
                }
                
                // If justification ready, declare war
                const justification = country.diplomacy.justifications.find(j => j.target === targetId);
                if (justification && justification.progress >= 100) {
                    if (!country.diplomacy.wars.includes(targetId)) {
                        country.diplomacy.wars.push(targetId);
                        countries[targetId].diplomacy.wars.push(country.id);
                        this.log(`${country.name} declared war on ${target.name}!`, "war");
                        country.diplomacy.justifications = country.diplomacy.justifications.filter(j => j.target !== targetId);
                    }
                }
            });
        }

        if (country.manpower > 500) {
            const borderProv = myProvs.find(p => p.neighbors.some(n => provinces.find(pr=>pr.id===n).owner !== country.id));
            if (borderProv) {
                country.manpower -= 100;
                borderProv.army += 50;
            }
        }
        myProvs.forEach(p => {
            if (p.army > 150) {
                const targets = p.neighbors.map(nid => provinces.find(pr => pr.id === nid));
                // Only attack if at war
                const weakTarget = targets.find(t => {
                    return t.owner !== country.id && 
                           country.diplomacy.wars.includes(t.owner) && 
                           t.army < p.army * 0.6;
                });
                if (weakTarget) this.resolveCombat(p, weakTarget);
            }
        });
    },

    togglePause: function() {
        this.paused = !this.paused;
        document.getElementById('btn-pause').innerText = this.paused ? "‚ñ∂" : "‚è∏";
    },

    // --- INPUT HANDLING (PANNING & CLICKING) ---

    handleMouseDown: function(e) {
        this.camera.isDragging = true;
        this.camera.lastX = e.clientX;
        this.camera.lastY = e.clientY;
    },

    handleMouseMove: function(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Panning
        if (this.camera.isDragging) {
            const dx = e.clientX - this.camera.lastX;
            const dy = e.clientY - this.camera.lastY;
            this.camera.x += dx;
            this.camera.y += dy;
            this.camera.lastX = e.clientX;
            this.camera.lastY = e.clientY;
            this.render();
            return; // Don't hover while dragging
        }

        // Hover
        // Convert mouse screen coords to world coords
        // The render transform is: 
        // 1. Translate(camera.x, camera.y)
        // 2. Scale(zoom, zoom)
        // 3. Translate(width/2/zoom, height/2/zoom)
        // 4. Scale(1, -1)
        
        // So to reverse:
        // worldY = (mouseY - camera.y) / zoom - height/2/zoom
        // worldY = -worldY (flip back)
        
        // Let's re-derive carefully from render:
        // screenX = (worldX + width/2/zoom) * zoom + camera.x
        // screenX = worldX * zoom + width/2 + camera.x
        // worldX = (screenX - camera.x - width/2) / zoom
        
        // screenY = (-worldY + height/2/zoom) * zoom + camera.y
        // screenY = -worldY * zoom + height/2 + camera.y
        // worldY = -(screenY - camera.y - height/2) / zoom
        
        const worldX = (mouseX - this.camera.x - this.canvas.width/2) / this.camera.zoom;
        const worldY = -(mouseY - this.camera.y - this.canvas.height/2) / this.camera.zoom;
        
        const tooltip = document.getElementById('tooltip');
        
        let hovered = null;
        
        // Check bounds first, then polygon
        for (let p of provinces) {
            if (worldX >= p.bounds.minX && worldX <= p.bounds.maxX &&
                worldY >= p.bounds.minY && worldY <= p.bounds.maxY) {
                
                let inside = false;
                for (let poly of p.polygons) {
                    if (this.pointInPolygon([worldX, worldY], poly)) {
                        inside = true;
                        break;
                    }
                }
                
                if (inside) {
                    hovered = p;
                    break; // Found the top one (assuming no overlap, or just take first)
                }
            }
        }

        if (hovered) {
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';
            tooltip.innerHTML = `
                <strong style="color:#fff">${hovered.name}</strong><br>
                <span style="color:${countries[hovered.owner].color}">${countries[hovered.owner].name}</span><br>
                Army: ${Math.floor(hovered.army)}
            `;
        } else {
            tooltip.style.display = 'none';
        }
    },

    handleMouseUp: function(e) {
        if (!this.camera.isDragging) return;
        this.camera.isDragging = false;
        
        // Check if it was a click (minimal movement)
        const dx = e.clientX - this.camera.lastX;
        const dy = e.clientY - this.camera.lastY;
        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) return; // Was a drag

        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const worldX = (mouseX - this.camera.x - this.canvas.width/2) / this.camera.zoom;
        const worldY = -(mouseY - this.camera.y - this.canvas.height/2) / this.camera.zoom;
        
        // Point in polygon check
        let clicked = null;
        for (let p of provinces) {
            // Bounds check optimization
            if (worldX < p.bounds.minX || worldX > p.bounds.maxX ||
                worldY < p.bounds.minY || worldY > p.bounds.maxY) continue;

            for (let poly of p.polygons) {
                if (this.pointInPolygon([worldX, worldY], poly)) {
                    clicked = p;
                    break;
                }
            }
            if (clicked) break;
        }

        if (clicked) {
            this.handleProvinceClick(clicked);
        } else {
            // Deselect if clicked on water
            this.selectedProvId = null;
            this.attackMode = false;
            this.updateUI();
            this.render();
        }
    },

    pointInPolygon: function(point, vs) {
        // Ray-casting algorithm based on
        // https://github.com/substack/point-in-polygon
        var x = point[0], y = point[1];
        var inside = false;
        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            var xi = vs[i][0], yi = vs[i][1];
            var xj = vs[j][0], yj = vs[j][1];
            var intersect = ((yi > y) != (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    },

    handleWheel: function(e) {
        e.preventDefault();
        const zoomSensitivity = 0.001;
        const delta = -e.deltaY * zoomSensitivity;
        const newZoom = Math.min(Math.max(this.camera.zoom + delta * this.camera.zoom, 1), 50);
        
        // Zoom towards mouse pointer
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        // Calculate world coordinates before zoom
        const worldX = (mouseX - this.camera.x - this.canvas.width/2) / this.camera.zoom;
        const worldY = -(mouseY - this.camera.y - this.canvas.height/2) / this.camera.zoom;
        
        // Adjust camera to keep world point under mouse
        // NewCamX = MouseX - (WorldX * NewZ + W/2)
        this.camera.x = mouseX - (worldX * newZoom + this.canvas.width/2);
        
        // NewCamY = MouseY - (WorldY * -NewZ + H/2)
        this.camera.y = mouseY - (worldY * -newZoom + this.canvas.height/2);
        
        this.camera.zoom = newZoom;
        
        this.render();
    },

    handleProvinceClick: function(clicked) {
        if (this.attackMode && this.selectedProvId !== null) {
            const source = provinces.find(p => p.id === this.selectedProvId);
            if (source.neighbors.includes(clicked.id)) {
                this.resolveCombat(source, clicked);
                this.attackMode = false;
                document.getElementById('map-area').style.cursor = 'grab';
            } else {
                this.log("Target out of range!", "info");
            }
        } else {
            this.selectedProvId = clicked.id;
            this.attackMode = false;
            document.getElementById('map-area').style.cursor = 'grab';
        }
        this.updateUI();
        this.render();
    },

    diplomacy: {
        proposeNAP: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const targetId = p.owner;
            const myId = game.playerCountry;
            
            if (targetId === myId) return;
            
            const me = countries[myId];
            const them = countries[targetId];
            
            // Check if already exists
            if (me.diplomacy.pacts.find(p => p.with === targetId)) {
                game.log(`Already have a pact with ${them.name}`, "info");
                return;
            }
            
            // Simple AI acceptance chance
            if (them.aggression > 0.8) {
                game.log(`${them.name} refused the Non-Aggression Pact.`, "war");
            } else {
                me.diplomacy.pacts.push({ type: 'NAP', with: targetId, turns: 30 });
                them.diplomacy.pacts.push({ type: 'NAP', with: myId, turns: 30 });
                game.log(`Signed Non-Aggression Pact with ${them.name} (30 days)`, "peace");
                game.updateUI();
            }
        },
        
        startJustification: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const targetId = p.owner;
            const myId = game.playerCountry;
            
            if (targetId === myId) return;
            
            const me = countries[myId];
            
            if (me.diplomacy.justifications.find(j => j.target === targetId)) {
                game.log(`Already justifying against ${countries[targetId].name}`, "info");
                return;
            }
            
            me.diplomacy.justifications.push({ target: targetId, progress: 0 });
            game.log(`Started justifying war goal against ${countries[targetId].name}...`, "war");
            game.updateUI();
        },
        
        declareWar: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const targetId = p.owner;
            const myId = game.playerCountry;
            
            if (targetId === myId) return;
            
            const me = countries[myId];
            const justification = me.diplomacy.justifications.find(j => j.target === targetId);
            
            if (!justification || justification.progress < 100) {
                game.log(`Cannot declare war! Justification not ready.`, "info");
                return;
            }
            
            // Check NAP
            if (me.diplomacy.pacts.find(p => p.with === targetId)) {
                game.log(`Cannot declare war! Non-Aggression Pact active.`, "info");
                return;
            }
            
            if (!me.diplomacy.wars.includes(targetId)) {
                me.diplomacy.wars.push(targetId);
                countries[targetId].diplomacy.wars.push(myId);
                game.log(`WAR DECLARED ON ${countries[targetId].name}!`, "war");
                
                // Remove justification after use
                me.diplomacy.justifications = me.diplomacy.justifications.filter(j => j.target !== targetId);
                game.updateUI();
            }
        }
    },

    actions: {
        recruit: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const c = countries[game.playerCountry];
            if (p.owner !== game.playerCountry) return;
            if (c.manpower >= 100) {
                c.manpower -= 100;
                p.army += 50;
                game.updateUI();
                game.render();
                game.log(`Reinforcements arrived in ${p.name}`, "info");
            }
        },
        build: function(type) {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const c = countries[game.playerCountry];
            if (p.owner !== game.playerCountry) return;
            const cost = type === 'factory' ? 500 : 300;
            if (c.manpower >= cost) {
                c.manpower -= cost;
                p.buildings[type]++;
                game.updateUI();
                game.render();
                game.log(`Construction complete in ${p.name}`, "info");
            }
        },
        attackMode: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            if (p.owner !== game.playerCountry) return;
            game.attackMode = true;
            document.getElementById('map-area').style.cursor = 'crosshair';
            game.log("Select target province...", "info");
        },
        cheatAnnex: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            if (p.owner === game.playerCountry) return;
            const oldOwner = p.owner;
            p.owner = game.playerCountry;
            p.army = 100;
            game.log(`CHEAT: Annexed ${p.name} from ${countries[oldOwner].name}`, "war");
            game.updateUI();
            game.render();
        }
    },

    resolveCombat: function(attackerProv, defenderProv) {
        // Check if at war
        const attackerCountry = countries[attackerProv.owner];
        const defenderCountry = countries[defenderProv.owner];
        
        if (attackerProv.owner === this.playerCountry) {
             if (!attackerCountry.diplomacy.wars.includes(defenderProv.owner)) {
                 this.log("You must declare war first!", "info");
                 return;
             }
        } else {
            // AI vs AI or AI vs Player logic
            // For now, assume AI declares war instantly if it attacks (simplified)
            if (!attackerCountry.diplomacy.wars.includes(defenderProv.owner)) {
                attackerCountry.diplomacy.wars.push(defenderProv.owner);
                defenderCountry.diplomacy.wars.push(attackerProv.owner);
                this.log(`${attackerCountry.name} declared war on ${defenderCountry.name}!`, "war");
            }
        }

        if (attackerProv.army < 20) return;
        const attackForce = Math.floor(attackerProv.army * 0.8);
        attackerProv.army -= attackForce;
        let defenseMult = 1.0 + (defenderProv.buildings.fort * 0.2);
        const defenseForce = defenderProv.army * defenseMult;
        const attackRoll = attackForce * (0.8 + Math.random() * 0.4);
        const defenseRoll = defenseForce * (0.8 + Math.random() * 0.4);

        if (attackRoll > defenseRoll) {
            const remaining = Math.floor(attackForce * 0.6);
            defenderProv.owner = attackerProv.owner;
            defenderProv.army = remaining;
            defenderProv.buildings.fort = 0;
            this.log(`${countries[attackerProv.owner].name} seized ${defenderProv.name}`, "war");
        } else {
            const remaining = Math.floor(defenderProv.army * 0.7);
            defenderProv.army = remaining;
            this.log(`Assault on ${defenderProv.name} repelled`, "info");
        }
        this.render();
        this.updateUI();
    },

    log: function(msg, type) {
        const panel = document.getElementById('log-content');
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.innerText = `D${this.day}: ${msg}`;
        panel.prepend(entry);
    },

    updateUI: function() {
        if (!this.playerCountry || !countries[this.playerCountry]) return;
        const p = countries[this.playerCountry];
        document.getElementById('player-manpower').innerText = Math.floor(p.manpower);
        document.getElementById('player-industry').innerText = p.industry;
        document.getElementById('player-provinces').innerText = provinces.filter(prov => prov.owner === this.playerCountry).length;

        const provPanel = document.getElementById('province-panel');
        if (this.selectedProvId !== null) {
            const prov = provinces.find(pr => pr.id === this.selectedProvId);
            provPanel.style.display = 'block';
            document.getElementById('prov-id').innerText = `#${prov.id}`;
            document.getElementById('prov-name').innerText = prov.name;
            
            const owner = countries[prov.owner];
            const ownerEl = document.getElementById('prov-owner');
            ownerEl.innerText = owner.name;
            ownerEl.style.color = owner.color;
            
            document.getElementById('prov-army').innerText = Math.floor(prov.army);
            document.getElementById('prov-defense').innerText = (prov.buildings.fort * 20) + "%";

            const isMine = prov.owner === this.playerCountry;
            document.getElementById('owner-actions').style.display = isMine ? 'block' : 'none';
            
            // Diplomacy UI Logic
            const diplomacySection = document.getElementById('diplomacy-section');
            const adminActions = document.getElementById('admin-actions');
            
            if (!isMine) {
                diplomacySection.style.display = 'block';
                const me = countries[this.playerCountry];
                const targetId = prov.owner;
                
                // Update Status Text
                let status = "Neutral";
                if (me.diplomacy.wars.includes(targetId)) status = "AT WAR";
                else if (me.diplomacy.pacts.find(p => p.with === targetId)) status = "Non-Aggression Pact";
                
                document.getElementById('diplomacy-status').innerText = `Status: ${status}`;
                document.getElementById('diplomacy-status').style.color = status === "AT WAR" ? "#ff4444" : (status === "Neutral" ? "#aaa" : "#44ff44");
                
                // Update Buttons
                const napBtn = document.getElementById('btn-nap');
                const justifyBtn = document.getElementById('btn-justify');
                const warBtn = document.getElementById('btn-declare-war');
                
                // NAP Button
                const hasNap = me.diplomacy.pacts.find(p => p.with === targetId);
                napBtn.disabled = hasNap || me.diplomacy.wars.includes(targetId);
                napBtn.innerText = hasNap ? `NAP Active (${hasNap.turns}d)` : "Non-Aggression Pact";
                
                // Justify Button
                const justification = me.diplomacy.justifications.find(j => j.target === targetId);
                justifyBtn.disabled = !!justification || me.diplomacy.wars.includes(targetId);
                justifyBtn.innerText = justification ? `Justifying... ${Math.floor(justification.progress)}%` : "Justify War Goal";
                
                // War Button
                warBtn.disabled = !justification || justification.progress < 100 || hasNap || me.diplomacy.wars.includes(targetId);
                
            } else {
                diplomacySection.style.display = 'none';
            }
            
            // Admin actions always visible for now (or move cheat annex to bottom)
            // document.getElementById('admin-actions').style.display = !isMine ? 'block' : 'none';
        } else {
            provPanel.style.display = 'none';
        }
    },

    render: function() {
        const ctx = this.ctx;
        ctx.save();
        ctx.fillStyle = CONFIG.colors.water;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Apply Camera
        ctx.translate(this.camera.x, this.camera.y);
        ctx.scale(this.camera.zoom, this.camera.zoom);
        
        // Center map roughly (GeoJSON is -180 to 180, -90 to 90)
        // Move (0,0) to center of screen if zoom is 1?
        // Actually, let's just translate so 0,0 is center of map
        ctx.translate(this.canvas.width/2 / this.camera.zoom, this.canvas.height/2 / this.camera.zoom);
        // Flip Y because canvas Y is down, Lat is up
        ctx.scale(1, -1);

        // Draw Water/Background
        // (Already filled)

        provinces.forEach(p => {
            ctx.beginPath();
            p.polygons.forEach(poly => {
                ctx.moveTo(poly[0][0], poly[0][1]);
                for (let i = 1; i < poly.length; i++) {
                    ctx.lineTo(poly[i][0], poly[i][1]);
                }
                ctx.closePath();
            });

            if (p.id === this.selectedProvId) {
                ctx.fillStyle = CONFIG.colors.selected;
            } else {
                ctx.fillStyle = countries[p.owner].color;
            }
            
            // Add shadow effect for "3D" look
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 2;
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            
            ctx.fill();
            
            // Reset shadow for stroke
            ctx.shadowColor = 'transparent';

            ctx.strokeStyle = CONFIG.colors.border;
            ctx.lineWidth = 0.5 / this.camera.zoom;
            if (p.id === this.selectedProvId) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2 / this.camera.zoom;
            }
            ctx.stroke();

            // Draw army/buildings at centroid
            // Scale text inverse to zoom so it stays readable
            ctx.save();
            ctx.translate(p.center.x, p.center.y);
            ctx.scale(1, -1); // Flip back for text
            const textScale = 1 / this.camera.zoom;
            ctx.scale(textScale, textScale);
            
            if (p.buildings.factory > 0) {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '10px Arial';
                ctx.fillText("‚öô", -5, 0);
            }
            if (p.buildings.fort > 0) {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '10px Arial';
                ctx.fillText("‚ôú", 5, 0);
            }
            ctx.restore();
        });
        
        ctx.restore();
    }
};

window.onload = function() {
    game.init();
};
</script>
</body>
</html>