<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Iron Dominion: World Strategy</title>
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <style>
        :root {
            --bg-color: #0a0a0a;
            --text-color: #ffd700;
            --accent-color: #ff9933;
            --border-color: #8b7355;
            --panel-bg: rgba(20, 20, 20, 0.95);
            --topbar-bg: rgba(10, 10, 10, 0.95);
            --success: #44ff44;
            --danger: #ff4444;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', monospace;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
        }

        /* --- TOP BAR (HOI4 Style) --- */
        #top-bar {
            height: 50px;
            background: var(--topbar-bg);
            border-bottom: 2px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 100;
        }

        .top-section {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .stat-box {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1.1em;
            font-weight: bold;
            color: #fff;
            background: rgba(255,255,255,0.05);
            padding: 5px 10px;
            border-radius: 4px;
            border: 1px solid #333;
        }

        .stat-icon { font-size: 1.2em; }

        #country-selector {
            background: #222;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 5px;
            font-family: inherit;
            font-weight: bold;
        }

        /* --- MAP AREA --- */
        #map-area {
            flex-grow: 1;
            position: relative;
            background: #050505;
            overflow: hidden;
            cursor: grab;
        }

        #map-area:active {
            cursor: grabbing;
        }

        canvas {
            display: block;
        }

        /* --- PROVINCE PANEL (Bottom Left) --- */
        #province-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: var(--panel-bg);
            border: 2px solid var(--border-color);
            padding: 15px;
            display: none; /* Hidden by default */
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            z-index: 90;
        }

        .panel-header {
            color: var(--accent-color);
            font-weight: bold;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
            margin-bottom: 10px;
            text-transform: uppercase;
            display: flex;
            justify-content: space-between;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        /* --- LOG PANEL (Bottom Right) --- */
        #log-panel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 300px;
            height: 150px;
            background: rgba(0,0,0,0.6);
            border: 1px solid #333;
            padding: 10px;
            overflow-y: auto;
            font-size: 0.8em;
            color: #aaa;
            pointer-events: none; /* Let clicks pass through if needed, but scroll might need events */
            pointer-events: auto;
        }

        .log-entry { margin-bottom: 4px; border-bottom: 1px solid #222; padding-bottom: 2px; }
        .log-entry.war { color: #ff4444; }
        .log-entry.peace { color: #44ff44; }
        .log-entry.info { color: #88ccff; }

        /* --- BUTTONS --- */
        .btn {
            background: #333;
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 6px 10px;
            cursor: pointer;
            text-transform: uppercase;
            font-family: inherit;
            font-weight: bold;
            font-size: 0.8em;
            transition: all 0.2s;
        }
        .btn:hover { background: var(--accent-color); color: #000; }
        .btn-block { width: 100%; margin-bottom: 5px; }
        .btn-danger { border-color: var(--danger); color: var(--danger); }
        .btn-danger:hover { background: var(--danger); color: #000; }

        /* --- MODALS --- */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }
        
        .modal-content {
            background: var(--panel-bg);
            border: 2px solid var(--accent-color);
            padding: 30px;
            max-width: 500px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 153, 51, 0.2);
        }

        h1 { margin: 0 0 20px 0; color: var(--accent-color); }
        h2 { margin: 0 0 15px 0; color: #fff; font-size: 1.2em; }
        p { line-height: 1.5; color: #ccc; margin-bottom: 20px; }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid var(--accent-color);
            padding: 8px;
            pointer-events: none;
            display: none;
            z-index: 200;
            font-size: 0.9em;
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- TOP BAR -->
    <div id="top-bar">
        <div class="top-section">
            <div style="font-weight: bold; color: var(--accent-color); margin-right: 15px;">IRON DOMINION</div>
            <div id="player-username" style="color: #88ccff; font-size: 0.9em; margin-right: 10px;">Commander</div>
            <div id="player-country-display" style="font-weight: bold; color: #fff; border: 1px solid #444; padding: 5px 10px; background: #222;">-</div>
        </div>

        <div class="top-section stats">
            <div class="stat-box" title="Manpower"><span class="stat-icon">üë•</span> <span id="player-manpower">0</span></div>
            <div class="stat-box" title="Industry"><span class="stat-icon">üè≠</span> <span id="player-industry">0</span></div>
            <div class="stat-box" title="Territory"><span class="stat-icon">üö©</span> <span id="player-provinces">0</span></div>
        </div>

        <div class="top-section">
            <div style="margin-right: 15px; color: #aaa;">DAY <span id="game-day" style="color: #fff; font-weight: bold;">1</span></div>
            <button class="btn" onclick="game.togglePause()" id="btn-pause">‚è∏</button>
            <button class="btn" onclick="window.location.href='index.html'" style="margin-left: 10px;">EXIT</button>
        </div>
    </div>

    <!-- MAP AREA -->
    <div id="map-area">
        <canvas id="gameCanvas"></canvas>
        <div id="loading-overlay" style="position: absolute; top:0; left:0; width:100%; height:100%; background: #000; display: flex; justify-content: center; align-items: center; z-index: 500;">
            <div style="text-align: center;">
                <h2 style="color: var(--accent-color);">GENERATING WORLD...</h2>
                <p id="loading-text" style="color: #888;">Subdividing provinces...</p>
            </div>
        </div>
        <div id="tooltip"></div>

        <!-- PROVINCE PANEL -->
        <div id="province-panel">
            <div class="panel-header">
                <span id="prov-name">Province</span>
                <span id="prov-id" style="font-size: 0.7em; color: #666;">#000</span>
            </div>
            
            <div style="margin-bottom: 15px;">
                <div class="stat-row"><span>Owner:</span> <span id="prov-owner">-</span></div>
                <div class="stat-row"><span>Garrison:</span> <span id="prov-army" style="color: #aaa;">0</span></div>
                <div class="stat-row"><span>Armies:</span> <span id="prov-armies" style="color: #aaa;">0</span></div>
                <div class="stat-row"><span>Fortification:</span> <span id="prov-defense" style="color: #aaa;">0%</span></div>
            </div>

            <div id="owner-actions">
                <button class="btn btn-block" onclick="game.actions.openArmyDesigner()">üéñÔ∏è Army Designer</button>
                <button class="btn btn-block" onclick="game.actions.recruit()">Recruit (+50 Army) <span style="float:right; color:#888">100MP</span></button>
                <button class="btn btn-block" onclick="game.actions.build('factory')">Build Factory <span style="float:right; color:#888">500MP</span></button>
                <button class="btn btn-block" onclick="game.actions.build('fort')">Build Fort <span style="float:right; color:#888">300MP</span></button>
                <button class="btn btn-block btn-danger" onclick="game.actions.attackMode()">‚öî LAUNCH ASSAULT</button>
            </div>
            
            <div id="admin-actions" style="margin-top: 10px; border-top: 1px solid #333; padding-top: 10px;">
                <div id="diplomacy-section" style="display: none;">
                    <div style="color: #aaa; font-size: 0.9em; margin-bottom: 5px;">DIPLOMACY</div>
                    <div id="diplomacy-status" style="margin-bottom: 5px; font-size: 0.8em;">Status: Neutral</div>
                    <button class="btn btn-block" id="btn-nap" onclick="game.diplomacy.proposeNAP()">Non-Aggression Pact</button>
                    <button class="btn btn-block" id="btn-justify" onclick="game.diplomacy.startJustification()">Justify War Goal</button>
                    <button class="btn btn-block btn-danger" id="btn-declare-war" onclick="game.diplomacy.declareWar()">DECLARE WAR</button>
                </div>
                <button class="btn btn-block" style="background: #442222; margin-top: 10px;" onclick="game.actions.cheatAnnex()">‚ö† FORCE ANNEX</button>
            </div>
        </div>

        <!-- ARMY DESIGNER MODAL -->
        <div id="army-designer-modal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 500px; text-align: left;">
                <h2 style="text-align: center;">‚öîÔ∏è ARMY DESIGNER</h2>
                <p style="text-align: center; font-size: 0.9em;">Configure and deploy a new army to the selected province.</p>
                
                <div id="army-unit-selector" style="margin: 20px 0;">
                    <div class="stat-row" style="margin-bottom: 10px;">
                        <span>üö∂ Infantry</span>
                        <span><button class="btn" onclick="game.armyDesigner.adjust('infantry', -1)">-</button> <span id="unit-infantry-count">0</span> <button class="btn" onclick="game.armyDesigner.adjust('infantry', 1)">+</button></span>
                    </div>
                    <div class="stat-row" style="margin-bottom: 10px;">
                        <span>üõ°Ô∏è Tanks</span>
                        <span><button class="btn" onclick="game.armyDesigner.adjust('tanks', -1)">-</button> <span id="unit-tanks-count">0</span> <button class="btn" onclick="game.armyDesigner.adjust('tanks', 1)">+</button></span>
                    </div>
                    <div class="stat-row" style="margin-bottom: 10px;">
                        <span>üí• Artillery</span>
                        <span><button class="btn" onclick="game.armyDesigner.adjust('artillery', -1)">-</button> <span id="unit-artillery-count">0</span> <button class="btn" onclick="game.armyDesigner.adjust('artillery', 1)">+</button></span>
                    </div>
                    <div class="stat-row" style="margin-bottom: 10px;">
                        <span>üéØ Anti-Air</span>
                        <span><button class="btn" onclick="game.armyDesigner.adjust('antiAir', -1)">-</button> <span id="unit-antiAir-count">0</span> <button class="btn" onclick="game.armyDesigner.adjust('antiAir', 1)">+</button></span>
                    </div>
                    <div class="stat-row" style="margin-bottom: 10px;">
                        <span>üî´ Anti-Tank</span>
                        <span><button class="btn" onclick="game.armyDesigner.adjust('antiTank', -1)">-</button> <span id="unit-antiTank-count">0</span> <button class="btn" onclick="game.armyDesigner.adjust('antiTank', 1)">+</button></span>
                    </div>
                </div>
                
                <div style="border-top: 1px solid #333; padding-top: 10px; margin-bottom: 15px;">
                    <div class="stat-row"><span>Total Units:</span> <span id="army-total-units">0</span></div>
                    <div class="stat-row"><span>Army Strength:</span> <span id="army-strength-preview">0</span></div>
                    <div class="stat-row"><span>Total Cost:</span> <span id="army-total-cost" style="color: var(--accent-color);">0 MP</span></div>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button id="deploy-army-btn" class="btn btn-block" onclick="game.armyDesigner.deploy()">üöÄ DEPLOY ARMY</button>
                    <button class="btn btn-block" onclick="game.armyDesigner.close()">CANCEL</button>
                </div>
            </div>
        </div>

        <!-- LOG PANEL -->
        <div id="log-panel">
            <div style="color: #666; font-size: 0.9em; border-bottom: 1px solid #333; margin-bottom: 5px;">COMMUNICATIONS LOG</div>
            <div id="log-content"></div>
        </div>
    </div>
</div>

<!-- SETUP MODAL -->
<div id="setup-modal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <h1>SELECT YOUR NATION</h1>
        <p>Choose a superpower to lead into the new world order.</p>
        
        <div id="country-selection-list" style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 30px;">
            <!-- Populated by JS -->
        </div>

        <div style="text-align: left; margin: 20px 0; background: rgba(0,0,0,0.3); padding: 15px;">
            <h2>BRIEFING</h2>
            <p><strong>DRAG</strong> to pan the map view.</p>
            <p><strong>CLICK</strong> on a province to select it.</p>
            <p><strong>MANAGE</strong> your economy and army using the bottom-left panel.</p>
            <p><strong>ATTACK</strong> neighbors by selecting your province, clicking "Launch Assault", then clicking a target.</p>
        </div>
    </div>
</div>

<!-- GAME OVER MODAL -->
<div id="overlay" class="modal" style="display: none;">
    <div class="modal-content">
        <h1 id="overlay-title">CAMPAIGN ENDED</h1>
        <p id="overlay-msg">The world has been unified.</p>
        <button class="btn" style="padding: 15px 40px;" onclick="location.reload()">RESTART WORLD</button>
    </div>
</div>

<script>
/**
 * IRON DOMINION - World Strategy Engine [R30]
 */

const CONFIG = {
    tickRate: 800,
    colors: {
        water: '#080808',
        neutral: '#2a2a2a',
        highlight: 'rgba(255, 255, 255, 0.15)',
        selected: 'rgba(255, 215, 0, 0.5)',
        border: '#000'
    }
};

// --- WORLD DATA ---
let countries = {};
let provinces = [];
let game = null;
let cachedMapCanvas = null; // Pre-rendered map for performance

// Army unit templates
const UNIT_TYPES = {
    infantry: { name: 'Infantry', icon: 'üö∂', attack: 10, defense: 15, cost: 100 },
    tanks: { name: 'Tanks', icon: 'üõ°Ô∏è', attack: 30, defense: 10, cost: 300 },
    artillery: { name: 'Artillery', icon: 'üí•', attack: 40, defense: 5, cost: 250 },
    antiAir: { name: 'Anti-Air', icon: 'üéØ', attack: 15, defense: 20, cost: 200 },
    antiTank: { name: 'Anti-Tank', icon: 'üî´', attack: 25, defense: 12, cost: 220 }
};

// Army class for deployed units
class Army {
    constructor(id, ownerId, provinceId, composition) {
        this.id = id;
        this.owner = ownerId;
        this.provinceId = provinceId;
        this.composition = composition; // { infantry: 5, tanks: 2, ... }
        this.strength = this.calculateStrength();
    }
    
    calculateStrength() {
        let str = 0;
        for (const [type, count] of Object.entries(this.composition)) {
            if (UNIT_TYPES[type]) {
                str += (UNIT_TYPES[type].attack + UNIT_TYPES[type].defense) * count;
            }
        }
        return str;
    }
    
    getTotalUnits() {
        return Object.values(this.composition).reduce((a, b) => a + b, 0);
    }
}

let armies = []; // Global armies array
let nextArmyId = 1;

// --- GENERATION ---

class Province {
    constructor(id, feature) {
        this.id = id;
        this.feature = feature;
        this.owner = null; // Set externally now
        this.name = "Province";
        this.army = 50 + Math.floor(Math.random() * 100);
        this.buildings = { factory: 0, fort: 0 };
        this.armies = []; // Array of deployed army units
        this.neighbors = [];
        
        // Calculate centroid and bounds
        this.polygons = [];
        if (feature.geometry.type === 'Polygon') {
            this.polygons.push(feature.geometry.coordinates[0]);
        } else if (feature.geometry.type === 'MultiPolygon') {
            feature.geometry.coordinates.forEach(poly => this.polygons.push(poly[0]));
        }
        
        this.center = this.calculateCentroid();
        this.bounds = this.calculateBounds();
    }

    calculateCentroid() {
        let x = 0, y = 0, n = 0;
        this.polygons.forEach(poly => {
            poly.forEach(pt => {
                x += pt[0];
                y += pt[1];
                n++;
            });
        });
        return { x: x/n, y: y/n };
    }

    calculateBounds() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        this.polygons.forEach(poly => {
            poly.forEach(pt => {
                if (pt[0] < minX) minX = pt[0];
                if (pt[0] > maxX) maxX = pt[0];
                if (pt[1] < minY) minY = pt[1];
                if (pt[1] > maxY) maxY = pt[1];
            });
        });
        return { minX, minY, maxX, maxY };
    }
}

const MAJOR_NATIONS = {
    "USA": { color: "#4488ff", name: "United States" },
    "CHN": { color: "#ff4444", name: "China" },
    "RUS": { color: "#cc4444", name: "Russia" },
    "DEU": { color: "#aaaaaa", name: "Germany" },
    "FRA": { color: "#4444ff", name: "France" },
    "GBR": { color: "#cc8888", name: "United Kingdom" },
    "JPN": { color: "#ffffff", name: "Japan" },
    "BRA": { color: "#44cc44", name: "Brazil" },
    "IND": { color: "#ff8844", name: "India" },
    "CAN": { color: "#ffcccc", name: "Canada" },
    "AUS": { color: "#44ccff", name: "Australia" },
    "ITA": { color: "#44aa44", name: "Italy" },
    "ESP": { color: "#cccc44", name: "Spain" },
    "TUR": { color: "#44aaaa", name: "Turkey" },
    "ZAF": { color: "#aa44aa", name: "South Africa" },
    "EGY": { color: "#cccc88", name: "Egypt" },
    "SAU": { color: "#448844", name: "Saudi Arabia" },
    "IRN": { color: "#44aa88", name: "Iran" },
    "PAK": { color: "#448888", name: "Pakistan" },
    "IDN": { color: "#aa8844", name: "Indonesia" },
    "KOR": { color: "#4444aa", name: "South Korea" },
    "MEX": { color: "#88aa44", name: "Mexico" }
};

// Microstates remain single-tile; all others should use real admin-1 provinces where available.
const MICROSTATE_COUNTRIES = new Set([
    "LIE", "MCO", "SMR", "VAT", "AND", "SGP", "BRN", "MUS"
]);

async function generateWorldMap() {
    provinces = [];
    countries = {};
    
    const loadingText = document.getElementById('loading-text');
    
    try {
        // 1. Load Countries (Metadata)
        loadingText.innerText = "Loading country data...";
        const worldResponse = await fetch('assets/world.json');
        const worldData = await worldResponse.json();
        
        // Process countries
        for (let feature of worldData.features) {
            // Full RGB random color with decent saturation and brightness
            const r = Math.floor(Math.random() * 180) + 40;
            const g = Math.floor(Math.random() * 180) + 40;
            const b = Math.floor(Math.random() * 180) + 40;
            let color = `rgb(${r}, ${g}, ${b})`;
            let name = feature.properties.name;
            
            if (MAJOR_NATIONS[feature.id]) {
                color = MAJOR_NATIONS[feature.id].color;
            }

            countries[feature.id] = {
                id: feature.id,
                name: name,
                color: color,
                manpower: 1000 + Math.floor(Math.random() * 2000),
                industry: 5 + Math.floor(Math.random() * 10),
                ai: true,
                aggression: Math.random(),
                diplomacy: { pacts: [], justifications: [], wars: [] }
            };
        }

        // 2. Load Provinces (Geometry)
        loadingText.innerText = "Loading province data...";
        let provData = { features: [] };
        try {
            const provResponse = await fetch('assets/provinces.json');
            if (provResponse.ok) {
                provData = await provResponse.json();
            } else {
                console.warn("Provinces file not found, falling back to country maps.");
            }
        } catch (e) {
            console.warn("Failed to load provinces, falling back.", e);
        }
        
        let provIndex = 0;
        const countriesWithProvinces = new Set();
        const missingProvinceCountries = [];
        
        // Process real provinces
        if (provData && provData.features) {
            for (let i = 0; i < provData.features.length; i++) {
                const feature = provData.features[i];
                const ownerId = feature.properties.adm0_a3;
                
                // Only add if owner exists in our countries list
                if (countries[ownerId]) {
                    createProvince(provIndex++, feature, ownerId);
                    countriesWithProvinces.add(ownerId);
                }
                
                if (i % 100 === 0) {
                    loadingText.innerText = `Processing provinces... (${i}/${provData.features.length})`;
                    await new Promise(r => setTimeout(r, 0));
                }
            }
        }

        // 3. Fallback for countries without provinces (keep microstates single-tile)
        loadingText.innerText = "Generating national territories...";
        for (let feature of worldData.features) {
            if (!countriesWithProvinces.has(feature.id)) {
                if (!MICROSTATE_COUNTRIES.has(feature.id)) {
                    missingProvinceCountries.push(feature.id);
                }
                createProvince(provIndex++, feature, feature.id);
            }
        }

        if (missingProvinceCountries.length > 0) {
            console.warn("Countries missing province data; using single-tile fallback:", missingProvinceCountries.join(", "));
        }

        // Calculate neighbors
        loadingText.innerText = "Calculating logistics...";
        await new Promise(r => setTimeout(r, 10));

        provinces.forEach(p1 => {
            provinces.forEach(p2 => {
                if (p1 === p2) return;
                // Use bounding box check first for speed
                if (p1.bounds.maxX < p2.bounds.minX || p1.bounds.minX > p2.bounds.maxX ||
                    p1.bounds.maxY < p2.bounds.minY || p1.bounds.minY > p2.bounds.maxY) return;

                const dx = p1.center.x - p2.center.x;
                const dy = p1.center.y - p2.center.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                // Increased threshold for real provinces which can be larger
                if (dist < 15) { 
                    p1.neighbors.push(p2.id);
                }
            });
        });
        
        console.log(`Generated ${provinces.length} provinces.`);
        
        // Pre-render map to cached canvas for performance
        loadingText.innerText = "Pre-rendering map...";
        await new Promise(r => setTimeout(r, 10));
        preRenderMap();
        
        document.getElementById('loading-overlay').style.display = 'none';
        
    } catch (e) {
        console.error("Failed to load map data", e);
        document.getElementById('loading-text').innerText = "Error loading map data: " + e.message;
    }
}

// Pre-render the entire map to an offscreen canvas
function preRenderMap() {
    // Calculate world bounds
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    provinces.forEach(p => {
        if (p.bounds.minX < minX) minX = p.bounds.minX;
        if (p.bounds.maxX > maxX) maxX = p.bounds.maxX;
        if (p.bounds.minY < minY) minY = p.bounds.minY;
        if (p.bounds.maxY > maxY) maxY = p.bounds.maxY;
    });
    
    const worldWidth = maxX - minX;
    const worldHeight = maxY - minY;
    const scale = 4; // Base resolution scale
    
    cachedMapCanvas = document.createElement('canvas');
    cachedMapCanvas.width = worldWidth * scale;
    cachedMapCanvas.height = worldHeight * scale;
    cachedMapCanvas.worldBounds = { minX, minY, maxX, maxY, scale };
    
    const ctx = cachedMapCanvas.getContext('2d');
    ctx.save();
    ctx.scale(scale, scale);
    ctx.translate(-minX, -minY);
    ctx.scale(1, -1);
    ctx.translate(0, -(maxY + minY));
    
    // Draw all provinces
    provinces.forEach(p => {
        ctx.beginPath();
        p.polygons.forEach(poly => {
            ctx.moveTo(poly[0][0], poly[0][1]);
            for (let i = 1; i < poly.length; i++) {
                ctx.lineTo(poly[i][0], poly[i][1]);
            }
            ctx.closePath();
        });
        ctx.fillStyle = countries[p.owner].color;
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 0.3;
        ctx.stroke();
    });
    
    ctx.restore();
    console.log(`Pre-rendered map: ${cachedMapCanvas.width}x${cachedMapCanvas.height}`);
}

function createProvince(id, feature, ownerId) {
    // Use real name if available
    const name = feature.properties.name || `${countries[ownerId].name} Territory`;
    
    const p = new Province(id, feature);
    p.owner = ownerId;
    p.name = name;
    provinces.push(p);
}

const REGION_NAMES = ["Region", "Sector", "Zone", "District", "Area", "Territory", "Province", "State"];
function generateRegionName() {
    return REGION_NAMES[Math.floor(Math.random() * REGION_NAMES.length)] + " " + Math.floor(Math.random()*100);
}

function generateCityName(region) {
    return "City"; // Deprecated
}

// --- GAME ENGINE ---

game = {
    canvas: null,
    ctx: null,
    day: 1,
    paused: false,
    selectedProvId: null,
    attackMode: false,
    timer: null,
    playerCountry: null,
    camera: { x: 0, y: 0, zoom: 4, isDragging: false, lastX: 0, lastY: 0 },
    keyState: new Set(),
    keyPanSpeed: 40,

    init: async function() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        const mapArea = document.getElementById('map-area');
        this.canvas.width = mapArea.clientWidth;
        this.canvas.height = mapArea.clientHeight;
        
        // Fetch username from MyTAD API
        try {
            const response = await fetch('/php/check-auth.php', { credentials: 'include' });
            const data = await response.json();
            if (data.authenticated && data.username) {
                this.playerUsername = data.username;
                document.getElementById('player-username').innerText = data.username;
            } else {
                this.playerUsername = 'Commander';
                document.getElementById('player-username').innerText = 'Commander';
            }
        } catch (e) {
            this.playerUsername = 'Commander';
            document.getElementById('player-username').innerText = 'Commander';
        }
        
        await generateWorldMap();
        
        // Check for country parameter in URL
        const urlParams = new URLSearchParams(window.location.search);
        const countryParam = urlParams.get('country');
        
        if (countryParam && countries[countryParam]) {
            this.startGame(countryParam);
        } else {
            this.initSetup();
        }
        
        this.render();
        
        // Input Handlers
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));
        this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
        window.addEventListener('keydown', this.handleKeyDown.bind(this));
        window.addEventListener('keyup', this.handleKeyUp.bind(this));
        this.startKeyLoop();
        
        window.addEventListener('resize', () => {
            this.canvas.width = mapArea.clientWidth;
            this.canvas.height = mapArea.clientHeight;
            this.render();
        });
        
        if (!this.playerCountry) {
            this.log("Waiting for commander selection...", "info");
        }
    },

    startKeyLoop: function() {
        const loop = () => {
            if (this.keyState.size > 0) {
                let moved = false;
                const step = this.keyPanSpeed;
                if (this.keyState.has('arrowleft') || this.keyState.has('a')) { this.camera.x += step; moved = true; }
                if (this.keyState.has('arrowright') || this.keyState.has('d')) { this.camera.x -= step; moved = true; }
                if (this.keyState.has('arrowup') || this.keyState.has('w')) { this.camera.y += step; moved = true; }
                if (this.keyState.has('arrowdown') || this.keyState.has('s')) { this.camera.y -= step; moved = true; }
                if (moved && !this.renderPending) {
                    this.renderPending = true;
                    requestAnimationFrame(() => {
                        this.render();
                        this.renderPending = false;
                    });
                }
            }
            requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
    },

    initSetup: function() {
        document.getElementById('setup-modal').style.display = 'flex';
        const container = document.getElementById('country-selection-list');
        container.innerHTML = "";
        
        // Sort countries by name
        const sortedCountries = Object.values(countries).sort((a, b) => a.name.localeCompare(b.name));

        sortedCountries.forEach(c => {
            if (c.id === "NEUTRAL") return;
            
            const btn = document.createElement('button');
            btn.className = 'btn';
            btn.style.padding = '10px';
            btn.style.width = '180px';
            btn.style.border = `1px solid ${c.color}`;
            btn.style.textAlign = 'left';
            btn.style.background = 'rgba(0,0,0,0.5)';
            
            btn.innerHTML = `
                <div style="color: ${c.color}; font-weight: bold;">${c.name}</div>
                <div style="font-size: 0.8em; color: #aaa;">MP: ${c.manpower}</div>
            `;
            
            btn.onclick = () => this.startGame(c.id);
            container.appendChild(btn);
        });
    },

    startGame: function(countryId) {
        this.playerCountry = countryId;
        document.getElementById('setup-modal').style.display = 'none';
        document.getElementById('player-country-display').innerText = countries[countryId].name;
        document.getElementById('player-country-display').style.color = countries[countryId].color;
        document.getElementById('player-country-display').style.borderColor = countries[countryId].color;
        
        this.updateUI();
        this.timer = setInterval(() => this.tick(), CONFIG.tickRate);
        this.log(`Commander assigned to ${countries[countryId].name}. Operation started.`, "info");
        this.render();
    },

    switchPlayer: function(countryId) {
        this.playerCountry = countryId;
        this.selectedProvId = null;
        this.attackMode = false;
        this.log(`Command switched to ${countries[countryId].name}`, "info");
        this.updateUI();
        this.render();
    },

    tick: function() {
        if (this.paused) return;
        this.day++;
        document.getElementById('game-day').innerText = this.day;

        Object.values(countries).forEach(c => {
            if (c.id === "NEUTRAL") return;
            
            // Diplomacy Updates
            if (c.diplomacy) {
                // Decrease pact duration
                c.diplomacy.pacts = c.diplomacy.pacts.filter(p => {
                    p.turns--;
                    if (p.turns <= 0) {
                        if (c.id === this.playerCountry) game.log(`Non-Aggression Pact with ${countries[p.with].name} expired.`, "info");
                        return false;
                    }
                    return true;
                });

                // Increase justification progress
                c.diplomacy.justifications.forEach(j => {
                    if (j.progress < 100) {
                        j.progress += 2; // 2% per day
                        if (j.progress >= 100) {
                            j.progress = 100;
                            if (c.id === this.playerCountry) game.log(`War Goal against ${countries[j.target].name} is ready!`, "war");
                        }
                    }
                });
            }

            const myProvs = provinces.filter(p => p.owner === c.id);
            if (myProvs.length === 0) return;

            let income = 10 + (myProvs.length * 2);
            const factories = myProvs.reduce((sum, p) => sum + p.buildings.factory, 0);
            income += factories * 5;
            
            c.manpower += income;
            c.industry = factories;

            if (c.ai && c.id !== this.playerCountry) this.processAI(c, myProvs);
        });

        this.updateUI();
        this.render();
    },

    processAI: function(country, myProvs) {
        // AI Diplomacy Logic
        if (country.diplomacy) {
            // Check neighbors
            const neighbors = new Set();
            myProvs.forEach(p => {
                p.neighbors.forEach(nid => {
                    const n = provinces.find(pr => pr.id === nid);
                    if (n.owner !== country.id) neighbors.add(n.owner);
                });
            });
            
            neighbors.forEach(targetId => {
                if (targetId === "NEUTRAL") return;
                const target = countries[targetId];
                
                // If aggressive and strong, justify war
                if (country.aggression > 0.7 && country.manpower > target.manpower * 1.2) {
                    // AI will NOT justify against player
                    if (targetId !== this.playerCountry && 
                        !country.diplomacy.wars.includes(targetId) && 
                        !country.diplomacy.pacts.find(p => p.with === targetId) &&
                        !country.diplomacy.justifications.find(j => j.target === targetId)) {
                            
                        country.diplomacy.justifications.push({ target: targetId, progress: 0 });
                        // Only log if player is involved or nearby? For now log all major events
                        if (targetId === this.playerCountry) {
                            this.log(`WARNING: ${country.name} is justifying a war goal against you!`, "war");
                        }
                    }
                }
                
                // If justification ready, declare war
                const justification = country.diplomacy.justifications.find(j => j.target === targetId);
                if (justification && justification.progress >= 100) {
                    if (!country.diplomacy.wars.includes(targetId)) {
                        country.diplomacy.wars.push(targetId);
                        countries[targetId].diplomacy.wars.push(country.id);
                        this.log(`${country.name} declared war on ${target.name}!`, "war");
                        country.diplomacy.justifications = country.diplomacy.justifications.filter(j => j.target !== targetId);
                    }
                }
            });
        }

        if (country.manpower > 500) {
            const borderProv = myProvs.find(p => p.neighbors.some(n => provinces.find(pr=>pr.id===n).owner !== country.id));
            if (borderProv) {
                country.manpower -= 100;
                borderProv.army += 50;
            }
        }
        myProvs.forEach(p => {
            if (p.army > 150) {
                const targets = p.neighbors.map(nid => provinces.find(pr => pr.id === nid));
                // Only attack if at war
                const weakTarget = targets.find(t => {
                    return t.owner !== country.id && 
                           country.diplomacy.wars.includes(t.owner) && 
                           t.army < p.army * 0.6;
                });
                if (weakTarget) this.resolveCombat(p, weakTarget);
            }
        });
    },

    togglePause: function() {
        this.paused = !this.paused;
        document.getElementById('btn-pause').innerText = this.paused ? "‚ñ∂" : "‚è∏";
    },

    // --- INPUT HANDLING (PANNING & CLICKING) ---

    handleMouseDown: function(e) {
        this.camera.isDragging = true;
        this.camera.lastX = e.clientX;
        this.camera.lastY = e.clientY;
    },

    handleMouseMove: function(e) {
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Panning
        if (this.camera.isDragging) {
            const dx = e.clientX - this.camera.lastX;
            const dy = e.clientY - this.camera.lastY;
            this.camera.x += dx;
            this.camera.y += dy;
            this.camera.lastX = e.clientX;
            this.camera.lastY = e.clientY;
            
            // Use requestAnimationFrame for smoother panning
            if (!this.renderPending) {
                this.renderPending = true;
                requestAnimationFrame(() => {
                    this.render();
                    this.renderPending = false;
                });
            }
            return; // Don't hover while dragging
        }

        // Hover
        // Convert mouse screen coords to world coords
        const worldX = (mouseX - this.camera.x - this.canvas.width/2) / this.camera.zoom;
        const worldY = -(mouseY - this.camera.y - this.canvas.height/2) / this.camera.zoom;
        
        const tooltip = document.getElementById('tooltip');
        
        let hovered = null;
        
        // Check bounds first, then polygon
        for (let p of provinces) {
            if (worldX >= p.bounds.minX && worldX <= p.bounds.maxX &&
                worldY >= p.bounds.minY && worldY <= p.bounds.maxY) {
                
                let inside = false;
                for (let poly of p.polygons) {
                    if (this.pointInPolygon([worldX, worldY], poly)) {
                        inside = true;
                        break;
                    }
                }
                
                if (inside) {
                    hovered = p;
                    break; // Found the top one (assuming no overlap, or just take first)
                }
            }
        }

        if (hovered) {
            tooltip.style.display = 'block';
            tooltip.style.left = (e.clientX + 15) + 'px';
            tooltip.style.top = (e.clientY + 15) + 'px';
            tooltip.innerHTML = `
                <strong style="color:#fff">${hovered.name}</strong><br>
                <span style="color:${countries[hovered.owner].color}">${countries[hovered.owner].name}</span><br>
                Army: ${Math.floor(hovered.army)}
            `;
        } else {
            tooltip.style.display = 'none';
        }
    },

    handleMouseUp: function(e) {
        if (!this.camera.isDragging) return;
        this.camera.isDragging = false;
        
        // Check if it was a click (minimal movement)
        const dx = e.clientX - this.camera.lastX;
        const dy = e.clientY - this.camera.lastY;
        if (Math.abs(dx) > 5 || Math.abs(dy) > 5) return; // Was a drag

        const rect = this.canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const worldX = (mouseX - this.camera.x - this.canvas.width/2) / this.camera.zoom;
        const worldY = -(mouseY - this.camera.y - this.canvas.height/2) / this.camera.zoom;
        
        // Point in polygon check
        let clicked = null;
        for (let p of provinces) {
            // Bounds check optimization
            if (worldX < p.bounds.minX || worldX > p.bounds.maxX ||
                worldY < p.bounds.minY || worldY > p.bounds.maxY) continue;

            for (let poly of p.polygons) {
                if (this.pointInPolygon([worldX, worldY], poly)) {
                    clicked = p;
                    break;
                }
            }
            if (clicked) break;
        }

        if (clicked) {
            this.handleProvinceClick(clicked);
        } else {
            // Deselect if clicked on water
            this.selectedProvId = null;
            this.attackMode = false;
            this.updateUI();
            this.render();
        }
    },

    pointInPolygon: function(point, vs) {
        // Ray-casting algorithm based on
        // https://github.com/substack/point-in-polygon
        var x = point[0], y = point[1];
        var inside = false;
        for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
            var xi = vs[i][0], yi = vs[i][1];
            var xj = vs[j][0], yj = vs[j][1];
            var intersect = ((yi > y) != (yj > y))
                && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    },

    handleWheel: function(e) {
        e.preventDefault();
        const zoomSensitivity = 0.001;
        const delta = -e.deltaY * zoomSensitivity;
        const factor = 1 + delta;
        this.adjustZoom(factor, e.clientX, e.clientY);
    },

    adjustZoom: function(factor, clientX = null, clientY = null) {
        const newZoom = Math.min(Math.max(this.camera.zoom * factor, 1), 50);
        const rect = this.canvas.getBoundingClientRect();
        const mouseX = clientX === null ? this.canvas.width / 2 : clientX - rect.left;
        const mouseY = clientY === null ? this.canvas.height / 2 : clientY - rect.top;

        const worldX = (mouseX - this.camera.x - this.canvas.width/2) / this.camera.zoom;
        const worldY = -(mouseY - this.camera.y - this.canvas.height/2) / this.camera.zoom;

        this.camera.x = mouseX - (worldX * newZoom + this.canvas.width/2);
        this.camera.y = mouseY - (worldY * -newZoom + this.canvas.height/2);
        this.camera.zoom = newZoom;

        if (!this.renderPending) {
            this.renderPending = true;
            requestAnimationFrame(() => {
                this.render();
                this.renderPending = false;
            });
        }
    },

    handleKeyDown: function(e) {
        const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : '';
        if (tag === 'input' || tag === 'textarea' || tag === 'select') return;

        const k = e.key.toLowerCase();
        if (k === ' ') { e.preventDefault(); this.togglePause(); return; }
        if (k === 'escape') { this.attackMode = false; this.selectedProvId = null; this.updateUI(); this.render(); return; }
        if (k === 'enter') { this.attackMode = !this.attackMode; this.updateUI(); this.render(); return; }
        if (k === '+' || k === '=' || k === 'add') { this.adjustZoom(1.1); return; }
        if (k === '-' || k === '_' || k === 'subtract') { this.adjustZoom(1/1.1); return; }

        this.keyState.add(k);
    },

    handleKeyUp: function(e) {
        const k = e.key.toLowerCase();
        this.keyState.delete(k);
    },

    handleProvinceClick: function(clicked) {
        if (this.attackMode && this.selectedProvId !== null) {
            const source = provinces.find(p => p.id === this.selectedProvId);
            if (source.neighbors.includes(clicked.id)) {
                this.resolveCombat(source, clicked);
                this.attackMode = false;
                document.getElementById('map-area').style.cursor = 'grab';
            } else {
                this.log("Target out of range!", "info");
            }
        } else {
            this.selectedProvId = clicked.id;
            this.attackMode = false;
            document.getElementById('map-area').style.cursor = 'grab';
        }
        this.updateUI();
        this.render();
    },

    diplomacy: {
        proposeNAP: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const targetId = p.owner;
            const myId = game.playerCountry;
            
            if (targetId === myId) return;
            
            const me = countries[myId];
            const them = countries[targetId];
            
            // Check if already exists
            if (me.diplomacy.pacts.find(p => p.with === targetId)) {
                game.log(`Already have a pact with ${them.name}`, "info");
                return;
            }
            
            // Simple AI acceptance chance
            if (them.aggression > 0.8) {
                game.log(`${them.name} refused the Non-Aggression Pact.`, "war");
            } else {
                me.diplomacy.pacts.push({ type: 'NAP', with: targetId, turns: 30 });
                them.diplomacy.pacts.push({ type: 'NAP', with: myId, turns: 30 });
                game.log(`Signed Non-Aggression Pact with ${them.name} (30 days)`, "peace");
                game.updateUI();
            }
        },
        
        startJustification: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const targetId = p.owner;
            const myId = game.playerCountry;
            
            if (targetId === myId) return;
            
            const me = countries[myId];
            
            if (me.diplomacy.justifications.find(j => j.target === targetId)) {
                game.log(`Already justifying against ${countries[targetId].name}`, "info");
                return;
            }
            
            me.diplomacy.justifications.push({ target: targetId, progress: 0 });
            game.log(`Started justifying war goal against ${countries[targetId].name}...`, "war");
            game.updateUI();
        },
        
        declareWar: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const targetId = p.owner;
            const myId = game.playerCountry;
            
            if (targetId === myId) return;
            
            const me = countries[myId];
            const justification = me.diplomacy.justifications.find(j => j.target === targetId);
            
            if (!justification || justification.progress < 100) {
                game.log(`Cannot declare war! Justification not ready.`, "info");
                return;
            }
            
            // Check NAP
            if (me.diplomacy.pacts.find(p => p.with === targetId)) {
                game.log(`Cannot declare war! Non-Aggression Pact active.`, "info");
                return;
            }
            
            if (!me.diplomacy.wars.includes(targetId)) {
                me.diplomacy.wars.push(targetId);
                countries[targetId].diplomacy.wars.push(myId);
                game.log(`WAR DECLARED ON ${countries[targetId].name}!`, "war");
                
                // Remove justification after use
                me.diplomacy.justifications = me.diplomacy.justifications.filter(j => j.target !== targetId);
                game.updateUI();
            }
        }
    },

    actions: {
        recruit: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const c = countries[game.playerCountry];
            if (p.owner !== game.playerCountry) return;
            if (c.manpower >= 100) {
                c.manpower -= 100;
                p.army += 50;
                game.updateUI();
                game.render();
                game.log(`Reinforcements arrived in ${p.name}`, "info");
            }
        },
        build: function(type) {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            const c = countries[game.playerCountry];
            if (p.owner !== game.playerCountry) return;
            const cost = type === 'factory' ? 500 : 300;
            if (c.manpower >= cost) {
                c.manpower -= cost;
                p.buildings[type]++;
                game.updateUI();
                game.render();
                game.log(`Construction complete in ${p.name}`, "info");
            }
        },
        attackMode: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            if (p.owner !== game.playerCountry) return;
            game.attackMode = true;
            document.getElementById('map-area').style.cursor = 'crosshair';
            game.log("Select target province...", "info");
        },
        cheatAnnex: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            if (p.owner === game.playerCountry) return;
            const oldOwner = p.owner;
            p.owner = game.playerCountry;
            p.army = 100;
            game.log(`CHEAT: Annexed ${p.name} from ${countries[oldOwner].name}`, "war");
            game.updateUI();
            game.render();
        },
        openArmyDesigner: function() {
            if (game.selectedProvId === null) return;
            const p = provinces.find(prov => prov.id === game.selectedProvId);
            if (p.owner !== game.playerCountry) return;
            game.armyDesigner.open(p.id);
        }
    },
    
    armyDesigner: {
        currentProvinceId: null,
        composition: { infantry: 10, tanks: 0, artillery: 0, antiAir: 0, antiTank: 0 },
        
        open: function(provinceId) {
            this.currentProvinceId = provinceId;
            this.composition = { infantry: 10, tanks: 0, artillery: 0, antiAir: 0, antiTank: 0 };
            this.updateUI();
            document.getElementById('army-designer-modal').style.display = 'flex';
        },
        
        close: function() {
            document.getElementById('army-designer-modal').style.display = 'none';
            this.currentProvinceId = null;
        },
        
        adjust: function(unitType, delta) {
            const current = this.composition[unitType] || 0;
            this.composition[unitType] = Math.max(0, current + delta);
            this.updateUI();
        },
        
        updateUI: function() {
            let totalCost = 0;
            let totalStrength = 0;
            
            Object.keys(this.composition).forEach(type => {
                const count = this.composition[type];
                const unit = UNIT_TYPES[type];
                if (unit && count > 0) {
                    totalCost += count * unit.cost;
                    totalStrength += count * (unit.attack + unit.defense);
                }
                
                const countEl = document.getElementById(`unit-${type}-count`);
                if (countEl) countEl.innerText = count;
            });
            
            document.getElementById('army-total-cost').innerText = totalCost;
            document.getElementById('army-strength-preview').innerText = totalStrength;
            
            const playerCountry = countries[game.playerCountry];
            const deployBtn = document.getElementById('deploy-army-btn');
            if (playerCountry && totalCost > playerCountry.manpower) {
                deployBtn.disabled = true;
                deployBtn.style.opacity = '0.5';
            } else {
                deployBtn.disabled = false;
                deployBtn.style.opacity = '1';
            }
        },
        
        deploy: function() {
            if (this.currentProvinceId === null) return;
            
            const prov = provinces.find(p => p.id === this.currentProvinceId);
            if (!prov || prov.owner !== game.playerCountry) return;
            
            let totalCost = 0;
            let totalUnits = 0;
            Object.keys(this.composition).forEach(type => {
                const count = this.composition[type];
                if (UNIT_TYPES[type] && count > 0) {
                    totalCost += count * UNIT_TYPES[type].cost;
                    totalUnits += count;
                }
            });
            
            if (totalUnits === 0) {
                game.log("Cannot deploy empty army!", "info");
                return;
            }
            
            const playerCountry = countries[game.playerCountry];
            if (totalCost > playerCountry.manpower) {
                game.log("Not enough manpower!", "info");
                return;
            }
            
            // Deduct cost
            playerCountry.manpower -= totalCost;
            
            // Create army
            const army = new Army(nextArmyId++, game.playerCountry, this.currentProvinceId, {...this.composition});
            armies.push(army);
            prov.armies.push(army.id);
            
            game.log(`Deployed army (${totalUnits} units) to ${prov.name}`, "info");
            this.close();
            game.updateUI();
            game.render();
        }
    },

    resolveCombat: function(attackerProv, defenderProv) {
        // Check if at war
        const attackerCountry = countries[attackerProv.owner];
        const defenderCountry = countries[defenderProv.owner];
        
        if (attackerProv.owner === this.playerCountry) {
             if (!attackerCountry.diplomacy.wars.includes(defenderProv.owner)) {
                 this.log("You must declare war first!", "info");
                 return;
             }
        } else {
            // AI vs AI or AI vs Player logic
            // For now, assume AI declares war instantly if it attacks (simplified)
            if (!attackerCountry.diplomacy.wars.includes(defenderProv.owner)) {
                attackerCountry.diplomacy.wars.push(defenderProv.owner);
                defenderCountry.diplomacy.wars.push(attackerProv.owner);
                this.log(`${attackerCountry.name} declared war on ${defenderCountry.name}!`, "war");
            }
        }

        if (attackerProv.army < 20) return;
        const attackForce = Math.floor(attackerProv.army * 0.8);
        attackerProv.army -= attackForce;
        let defenseMult = 1.0 + (defenderProv.buildings.fort * 0.2);
        const defenseForce = defenderProv.army * defenseMult;
        const attackRoll = attackForce * (0.8 + Math.random() * 0.4);
        const defenseRoll = defenseForce * (0.8 + Math.random() * 0.4);

        if (attackRoll > defenseRoll) {
            const remaining = Math.floor(attackForce * 0.6);
            defenderProv.owner = attackerProv.owner;
            defenderProv.army = remaining;
            defenderProv.buildings.fort = 0;
            this.log(`${countries[attackerProv.owner].name} seized ${defenderProv.name}`, "war");
        } else {
            const remaining = Math.floor(defenderProv.army * 0.7);
            defenderProv.army = remaining;
            this.log(`Assault on ${defenderProv.name} repelled`, "info");
        }
        this.render();
        this.updateUI();
    },

    log: function(msg, type) {
        const panel = document.getElementById('log-content');
        const entry = document.createElement('div');
        entry.className = `log-entry ${type}`;
        entry.innerText = `D${this.day}: ${msg}`;
        panel.prepend(entry);
    },

    updateUI: function() {
        if (!this.playerCountry || !countries[this.playerCountry]) return;
        const p = countries[this.playerCountry];
        document.getElementById('player-manpower').innerText = Math.floor(p.manpower);
        document.getElementById('player-industry').innerText = p.industry;
        document.getElementById('player-provinces').innerText = provinces.filter(prov => prov.owner === this.playerCountry).length;

        const provPanel = document.getElementById('province-panel');
        if (this.selectedProvId !== null) {
            const prov = provinces.find(pr => pr.id === this.selectedProvId);
            provPanel.style.display = 'block';
            document.getElementById('prov-id').innerText = `#${prov.id}`;
            document.getElementById('prov-name').innerText = prov.name;
            
            const owner = countries[prov.owner];
            const ownerEl = document.getElementById('prov-owner');
            ownerEl.innerText = owner.name;
            ownerEl.style.color = owner.color;
            
            document.getElementById('prov-army').innerText = Math.floor(prov.army);
            document.getElementById('prov-defense').innerText = (prov.buildings.fort * 20) + "%";
            document.getElementById('prov-armies').innerText = prov.armies.length;

            const isMine = prov.owner === this.playerCountry;
            document.getElementById('owner-actions').style.display = isMine ? 'block' : 'none';
            
            // Diplomacy UI Logic
            const diplomacySection = document.getElementById('diplomacy-section');
            const adminActions = document.getElementById('admin-actions');
            
            if (!isMine) {
                diplomacySection.style.display = 'block';
                const me = countries[this.playerCountry];
                const targetId = prov.owner;
                
                // Update Status Text
                let status = "Neutral";
                if (me.diplomacy.wars.includes(targetId)) status = "AT WAR";
                else if (me.diplomacy.pacts.find(p => p.with === targetId)) status = "Non-Aggression Pact";
                
                document.getElementById('diplomacy-status').innerText = `Status: ${status}`;
                document.getElementById('diplomacy-status').style.color = status === "AT WAR" ? "#ff4444" : (status === "Neutral" ? "#aaa" : "#44ff44");
                
                // Update Buttons
                const napBtn = document.getElementById('btn-nap');
                const justifyBtn = document.getElementById('btn-justify');
                const warBtn = document.getElementById('btn-declare-war');
                
                // NAP Button
                const hasNap = me.diplomacy.pacts.find(p => p.with === targetId);
                napBtn.disabled = hasNap || me.diplomacy.wars.includes(targetId);
                napBtn.innerText = hasNap ? `NAP Active (${hasNap.turns}d)` : "Non-Aggression Pact";
                
                // Justify Button
                const justification = me.diplomacy.justifications.find(j => j.target === targetId);
                justifyBtn.disabled = !!justification || me.diplomacy.wars.includes(targetId);
                justifyBtn.innerText = justification ? `Justifying... ${Math.floor(justification.progress)}%` : "Justify War Goal";
                
                // War Button
                warBtn.disabled = !justification || justification.progress < 100 || hasNap || me.diplomacy.wars.includes(targetId);
                
            } else {
                diplomacySection.style.display = 'none';
            }
            
            // Admin actions always visible for now (or move cheat annex to bottom)
            // document.getElementById('admin-actions').style.display = !isMine ? 'block' : 'none';
        } else {
            provPanel.style.display = 'none';
        }
    },

    render: function() {
        const ctx = this.ctx;
        ctx.save();
        ctx.fillStyle = CONFIG.colors.water;
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Apply Camera
        ctx.translate(this.camera.x, this.camera.y);
        ctx.scale(this.camera.zoom, this.camera.zoom);
        
        // Center map roughly
        ctx.translate(this.canvas.width/2 / this.camera.zoom, this.canvas.height/2 / this.camera.zoom);
        // Flip Y because canvas Y is down, Lat is up
        ctx.scale(1, -1);

        // Calculate Viewport Bounds in World Coordinates
        const minWorldX = (0 - this.camera.x - this.canvas.width/2) / this.camera.zoom;
        const maxWorldX = (this.canvas.width - this.camera.x - this.canvas.width/2) / this.camera.zoom;
        const maxWorldY = -(0 - this.camera.y - this.canvas.height/2) / this.camera.zoom;
        const minWorldY = -(this.canvas.height - this.camera.y - this.canvas.height/2) / this.camera.zoom;

        // Draw provinces (with selection highlight)
        provinces.forEach(p => {
            // Culling Check
            if (p.bounds.maxX < minWorldX || p.bounds.minX > maxWorldX ||
                p.bounds.maxY < minWorldY || p.bounds.minY > maxWorldY) {
                return;
            }

            ctx.beginPath();
            p.polygons.forEach(poly => {
                ctx.moveTo(poly[0][0], poly[0][1]);
                for (let i = 1; i < poly.length; i++) {
                    ctx.lineTo(poly[i][0], poly[i][1]);
                }
                ctx.closePath();
            });

            if (p.id === this.selectedProvId) {
                ctx.fillStyle = CONFIG.colors.selected;
            } else {
                ctx.fillStyle = countries[p.owner].color;
            }
            
            ctx.fill();
            
            ctx.strokeStyle = CONFIG.colors.border;
            ctx.lineWidth = 0.5 / this.camera.zoom;
            if (p.id === this.selectedProvId) {
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2 / this.camera.zoom;
            }
            ctx.stroke();

            // Draw buildings at centroid
            ctx.save();
            ctx.translate(p.center.x, p.center.y);
            ctx.scale(1, -1);
            const textScale = 1 / this.camera.zoom;
            ctx.scale(textScale, textScale);
            
            if (p.buildings.factory > 0) {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '10px Arial';
                ctx.fillText("‚öô", -5, 0);
            }
            if (p.buildings.fort > 0) {
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                ctx.font = '10px Arial';
                ctx.fillText("‚ôú", 5, 0);
            }
            ctx.restore();
        });
        
        // Draw armies as dots on the map
        armies.forEach(army => {
            const prov = provinces.find(p => p.id === army.provinceId);
            if (!prov) return;
            
            // Culling check
            if (prov.bounds.maxX < minWorldX || prov.bounds.minX > maxWorldX ||
                prov.bounds.maxY < minWorldY || prov.bounds.minY > maxWorldY) {
                return;
            }
            
            ctx.save();
            ctx.translate(prov.center.x, prov.center.y);
            
            // Draw army dot
            const dotSize = Math.max(2, Math.min(8, army.getTotalUnits() / 5)) / this.camera.zoom;
            const ownerColor = countries[army.owner] ? countries[army.owner].color : '#fff';
            
            ctx.beginPath();
            ctx.arc(0, 0, dotSize, 0, Math.PI * 2);
            ctx.fillStyle = ownerColor;
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1 / this.camera.zoom;
            ctx.stroke();
            
            // Draw unit count
            ctx.scale(1, -1);
            const textScale = 1 / this.camera.zoom;
            ctx.scale(textScale, textScale);
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 8px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(army.getTotalUnits().toString(), 0, -dotSize * this.camera.zoom - 3);
            
            ctx.restore();
        });
        
        ctx.restore();
    }
};

window.onload = function() {
    game.init();
};
</script>
</body>
</html>